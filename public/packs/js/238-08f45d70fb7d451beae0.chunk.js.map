{"version":3,"sources":["webpack:///./node_modules/prismjs/components/prism-lisp.js"],"names":["Prism","simple_form","name","RegExp","primitive","pattern","symbol","par","endpar","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","number","defvar","variable","defun","arguments","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","lisp","elisp","emacs"],"mappings":"8EAAA,SAAWA,GAIT,SAASC,EAAYC,GACnB,OAAOC,OAAO,QAAUD,EAAO,gBAIjC,SAASE,EAAUC,GACjB,OAAOF,OAAO,YAAcE,EAAU,cAMxC,IAAIC,EAAS,yBAITC,EAAM,QACNC,EAAS,UAGTC,EAAW,CAGbC,QAAS,CACPL,QAAS,QACTM,MAAO,CAAC,UAAW,UAErBC,QAAS,MACTC,OAAQ,CACNR,QAAS,oBACTS,QAAQ,EACRC,OAAQ,CACNC,SAAU,oBACVV,OAAQH,OAAO,IAAMG,EAAS,OAGlC,gBAAiB,CACfD,QAASF,OAAO,MAAQG,GACxBK,MAAO,CAAC,WAAY,WAEtB,gBAAiB,CACfN,QAASF,OAAO,IAAMG,GACtBK,MAAO,YAETM,OAAQ,CACNZ,QAASF,OAAO,MAAQG,GACxBK,MAAO,CAAC,SAAU,aAEpBO,QAAS,CAAC,CACRb,QAASF,OAAOI,2JAChBY,YAAY,GACX,CACDd,QAASF,OAAOI,qEAChBY,YAAY,IAEdC,QAAS,CACPf,QAASJ,EAAY,WACrBkB,YAAY,EACZR,MAAO,WAETU,YAAa,CACXhB,QAASJ,EAAY,eACrBkB,YAAY,EACZR,MAAO,WAET,QAAW,CACTN,QAASD,EAAU,aACnBe,YAAY,GAEdG,OAAQ,CACNjB,QAASD,EAAU,yBACnBe,YAAY,GAEdI,OAAQ,CACNlB,QAASF,OAAOI,yCAA4CD,GAC5Da,YAAY,EACZJ,OAAQ,CACNG,QAAS,aACTM,SAAUrB,OAAOG,KAGrBmB,MAAO,CACLpB,QAASF,OAAOI,0CAA6CD,EAAS,wBACtEa,YAAY,EACZJ,OAAQ,CACNG,QAAS,kBAGTQ,UAAW,KACX,SAAY,CACVrB,QAASF,OAAO,SAAWG,GAC3Ba,YAAY,GAEdQ,YAAa,SAGjBC,OAAQ,CACNvB,QAASF,OAAOI,0BAA6BD,EAAS,aACtDa,YAAY,EACZJ,OAAQ,CACNG,QAAS,UAGTQ,UAAW,KACXC,YAAa,SAGjBE,IAAK,CACHxB,QAASF,OAAOI,EAAMD,GACtBa,YAAY,GAEdQ,YAAa,CACb,uBACA,CACEtB,QAAS,eACTc,YAAY,KAGZW,EAAM,CACR,cAAe3B,OAzGJ,2BA0GX4B,KAAM,CACJf,SAAU,CACRX,QAASF,OAAOG,GAChBK,MAAO,YAETqB,QAAS,CACP3B,QAASF,OAAOI,EAAMD,EAAS,mBAAqBE,GACpDW,YAAY,EACZJ,OAAQ,CACNF,OAAQJ,EAASI,OACjB,QAAWJ,EAAkB,QAC7Ba,OAAQb,EAASa,OACjBhB,OAAQG,EAASH,OACjBqB,YAAa,WAKjBM,EAAQ,oBACRC,EAAU,CACZ7B,QAASF,OAAOI,yBAChBY,YAAY,EACZJ,OAAQ,CACN,YAAa,CACXV,QAASF,OAAO,qBAAuB8B,GACvClB,OAAQe,GAEV,oBAAqB,CACnBzB,QAASF,OAAO,wBAA0B8B,GAC1ClB,OAAQe,GAEVK,KAAM,CACJ9B,QAASF,OAAO,WAAa8B,EAAQ,8BACrClB,OAAQe,GAEVd,SAAU,CACRX,QAASF,OAAOG,GAChBK,MAAO,YAETgB,YAAa,SAGjBlB,EAAiB,OAAEM,OAAOW,UAAYQ,EACtCzB,EAAgB,MAAEM,OAAOW,UAAY1B,EAAMoC,KAAKC,MAAMH,GACtDzB,EAAgB,MAAEM,OAAOW,UAAUX,OAAOuB,QAAUJ,EACpDlC,EAAMuC,UAAUC,KAAO/B,EACvBT,EAAMuC,UAAUE,MAAQhC,EACxBT,EAAMuC,UAAUG,MAAQjC,EACxBT,EAAMuC,UAAU,cAAgB9B,EA5KlC,CA6KGT","file":"js/238-08f45d70fb7d451beae0.chunk.js","sourcesContent":["(function (Prism) {\n  // Functions to construct regular expressions\n  // simple form\n  // e.g. (interactive ... or (interactive)\n  function simple_form(name) {\n    return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n  } // booleans and numbers\n\n\n  function primitive(pattern) {\n    return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n  } // Patterns in regular expressions\n  // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n  // & and : are excluded as they are usually used for special purposes\n\n\n  var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+'; // symbol starting with & used in function arguments\n\n  var marker = '&' + symbol; // Open parenthesis for look-behind\n\n  var par = '(\\\\()';\n  var endpar = '(?=\\\\))'; // End the pattern with look-ahead space\n\n  var space = '(?=\\\\s)';\n  var language = {\n    // Three or four semicolons are considered a heading.\n    // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n    heading: {\n      pattern: /;;;.*/,\n      alias: ['comment', 'title']\n    },\n    comment: /;.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true,\n      inside: {\n        argument: /[-A-Z]+(?=[.,\\s])/,\n        symbol: RegExp('`' + symbol + \"'\")\n      }\n    },\n    'quoted-symbol': {\n      pattern: RegExp(\"#?'\" + symbol),\n      alias: ['variable', 'symbol']\n    },\n    'lisp-property': {\n      pattern: RegExp(':' + symbol),\n      alias: 'property'\n    },\n    splice: {\n      pattern: RegExp(',@?' + symbol),\n      alias: ['symbol', 'variable']\n    },\n    keyword: [{\n      pattern: RegExp(par + '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' + space),\n      lookbehind: true\n    }, {\n      pattern: RegExp(par + '(?:for|do|collect|return|finally|append|concat|in|by)' + space),\n      lookbehind: true\n    }],\n    declare: {\n      pattern: simple_form('declare'),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    interactive: {\n      pattern: simple_form('interactive'),\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    \"boolean\": {\n      pattern: primitive('(?:t|nil)'),\n      lookbehind: true\n    },\n    number: {\n      pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n      lookbehind: true\n    },\n    defvar: {\n      pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n      lookbehind: true,\n      inside: {\n        keyword: /^def[a-z]+/,\n        variable: RegExp(symbol)\n      }\n    },\n    defun: {\n      pattern: RegExp(par + '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' + symbol + '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'),\n      lookbehind: true,\n      inside: {\n        keyword: /^(?:cl-)?def\\S+/,\n        // See below, this property needs to be defined later so that it can\n        // reference the language object.\n        arguments: null,\n        \"function\": {\n          pattern: RegExp('(^\\\\s)' + symbol),\n          lookbehind: true\n        },\n        punctuation: /[()]/\n      }\n    },\n    lambda: {\n      pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n      lookbehind: true,\n      inside: {\n        keyword: /^lambda/,\n        // See below, this property needs to be defined later so that it can\n        // reference the language object.\n        arguments: null,\n        punctuation: /[()]/\n      }\n    },\n    car: {\n      pattern: RegExp(par + symbol),\n      lookbehind: true\n    },\n    punctuation: [// open paren, brackets, and close paren\n    /(?:['`,]?\\(|[)\\[\\]])/, // cons\n    {\n      pattern: /(\\s)\\.(?=\\s)/,\n      lookbehind: true\n    }]\n  };\n  var arg = {\n    'lisp-marker': RegExp(marker),\n    rest: {\n      argument: {\n        pattern: RegExp(symbol),\n        alias: 'variable'\n      },\n      varform: {\n        pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n        lookbehind: true,\n        inside: {\n          string: language.string,\n          \"boolean\": language[\"boolean\"],\n          number: language.number,\n          symbol: language.symbol,\n          punctuation: /[()]/\n        }\n      }\n    }\n  };\n  var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n  var arglist = {\n    pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n    lookbehind: true,\n    inside: {\n      'rest-vars': {\n        pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n        inside: arg\n      },\n      'other-marker-vars': {\n        pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n        inside: arg\n      },\n      keys: {\n        pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n        inside: arg\n      },\n      argument: {\n        pattern: RegExp(symbol),\n        alias: 'variable'\n      },\n      punctuation: /[()]/\n    }\n  };\n  language['lambda'].inside.arguments = arglist;\n  language['defun'].inside.arguments = Prism.util.clone(arglist);\n  language['defun'].inside.arguments.inside.sublist = arglist;\n  Prism.languages.lisp = language;\n  Prism.languages.elisp = language;\n  Prism.languages.emacs = language;\n  Prism.languages['emacs-lisp'] = language;\n})(Prism);"],"sourceRoot":""}